<html lang="en">
  <head>
    <title>Hello Longevity - Activator Template</title>
  </head>
  <body>

    <div>
      <h2>Getting Started with longevity</h2>

      <p>
        This tutorial walks through the basic steps needed to get
        started building a real-life application
        with <a href="http://longevityframework.github.io/longevity/">longevity</a>. The
        application we will be looking at here is a sample blogging
        application, built with longevity on the back end, and using
        <a href="http://doc.akka.io/docs/akka/2.4.7/scala/http/">Akka
        HTTP</a> for a REST API that could be used by a web client.
      </p>

      <p>
        We will only have the chance to cover a portion of the
        blogging application code
        in this tutorial, so please feel free to explore the codebase
        further on your own. You can also look to
        the <a href="http://longevityframework.github.io/longevity/manual/">user
        manual</a> for more information.
      </p>
    </div>
    
    <div>
      <h2>Modeling our Subdomain</h2>

      <p>
        We have
        four <a href="http://longevityframework.github.io/longevity/manual/ddd-basics/aggregates-and-entities.html">entity
        aggregates</a> in our domain model: users, blogs, blog posts,
        and comments. The arrows in this diagram indicate
        relationships between aggregates: comments are made on blog
        posts; blog posts are made in a blog; and blogs, blog posts
        and comments all have authors:
      </p>

      <p>
        <img src="tutorial/domain-model.png">
      </p>

      <p>
        For the purposes of this tutorial, we are going to focus in on
        the user aggregate. This aggregate consists of two entities: the
        user itself, and the user profile:
      </p>
      
      <p>
        <img src="tutorial/user-aggregate.png">
      </p>

    </div>

    <div>
      <h2>Building the User Aggregate</h2>

      <p>
        The user aggregate has four parts: the <code>User</code>,
        the <code>UserProfile</code>, and two natural keys:
        the <code>Username</code> and the <code>Email</code>.
        Let's focus on the <code>User</code> first, since that is the
        heart of the aggregate. You can find the source code
        for <code>User</code> <a href="#code/src/main/scala/simbl/domain/User.scala"
                                 class="shortcut">here</a>
      </p>

      <p>
        The <code>User</code> is a simple case class that extends
        longevity trait <code>Root</code>. <code>Root</code> extends
        the empty trait <code>Persistent</code>, which we use to mark
        things we want to persist to the database. We could
        use <code>Persistent</code> here instead, but we
        use <code>Root</code> because <code>User</code> is
        the <a href="http://longevityframework.github.io/longevity/manual/ddd-basics/aggregates-and-entities.html">aggregate
        root</a>.
      </p>

      <p>
        The <code>User</code> case class provides us with the four
        members we find in the UML in the
        <a href="#tutorial/1">previous section</a>, including the
        relationship between <code>User</code>
        and <code>UserProfile</code>. There are also a couple of
        business methods inside: <code>updateProfile</code>
        and <code>deleteProfile</code>. These methods are pretty
        trivial, but they provide us with examples of business
        methods that we will use later on.
      </p>

      <p>
        The <code>User</code> companion object provides metadata about
        the <code>User</code>: stuff that pertains not to an
        individual user, but to a collection of them. We first specify
        two properties, <code>User.props.username</code>
        and <code>User.props.email</code>, that we use to refer to
        members of <code>User</code> objects. Then we define two
        keys: <code>User.keys.username</code>
        and <code>User.keys.email</code>, that specifies that these
        two member are to be unique: no two users should have the same
        username or email.
      </p>

      <p>
        The <code>User</code> companion object
        extends <code>RootType</code>, a subclass
        of <code>PType</code>, which is a type class for
        a <code>Persistent</code>. Every <code>PType</code> defines
        its <code>props</code>, <code>keys</code>,
            and <code>indexes</code>, as you see in this example.
      </p>
      
    </div>

    <div>
      <h2>The User Profile</h2>

      <p>
        The <a href="#code/src/main/scala/simbl/domain/UserProfile.scala"
               class="shortcut">user profile</a> is an entity that is
               part of the user aggregate. It's a simple case class
               that extends
               trait <code>Entity</code>. <code>Entity</code> is a
               subclas of the empty trait <code>Embeddable</code>
               which we use to mark things that we want to embed in
        our persistent objects.
      </p>

      <p>
        The <code>UserProfile</code> has two members that are
        also <code>Embeddables</code>: <a href="#code/src/main/scala/simbl/domain/Uri.scala"
        class="shortcut"><code>Uri</code></a>
        and <a href="#code/src/main/scala/simbl/domain/Markdown.scala"
        class="shortcut"><code>Markdown</code></a>. These are simple
        wrapper classes for strings, which provide type safety, but
        are also places where we might add some extra functionality in
        the future. For instance, the <code>Uri</code> constructor might
        throw some kind of validation exception if the provided string
        is not a valid URI. Both of these classes
        are <code>ValueObjects</code>, which also extends
        the <code>Embeddable</code> trait. As you can see, we can
        freely nest <code>Embeddables</code> within
        our <code>Persistent</code> classes.
      </p>

      <p>
        We also provide an <code>EntityType</code> in
        the <code>UserProfile</code> companion
        object. <code>EntityType</code> is a subclass
        of <code>EType</code>, which is a type class for
        an <code>Embeddable</code>. There's nothing fancy inside it,
        but we need this class to make longevity aware of what kinds
        of things might be embedded in our persistent objects.
      </p>
    </div>
    
    <div>
      <h2>Username and Email</h2>

      <p>
        The final components of our user aggregate are
        <a href="#code/src/main/scala/simbl/domain/Username.scala"
        class="shortcut"><code>Username</code></a> and
        <a href="#code/src/main/scala/simbl/domain/Email.scala"
        class="shortcut"><code>Email</code></a>, which are the key
        values for our natural keys, <code>User.keys.username</code>
        and <code>User.keys.email</code>, respectively. Aside from
        being parts of our user aggregate, we can also embed them in
        other classes, such as 
        <a href="#code/src/main/scala/simbl/domain/BlogPost.scala"
        class="shortcut"><code>BlogPost</code></a>, (see line 16), to
        describe a relationship between a blog post and its authors.
      </p>
    </div>

    <div>
      <h2>Building the Subdomain</h2>

      <p>
        Once the classes of
        our <a href="http://longevityframework.github.io/longevity/manual/ddd-basics/subdomains-and-bounded-contexts.html">subdomain</a>
        have been created, we gather them all together into
        a <code>Subdomain</code> object. We do this in
        <a href="#code/src/main/scala/simbl/domain/SimblCoreDomain.scala"
        class="shortcut"><code>SimblCoreDomain</code></a> by extending
        abstract class <code>CoreDomain</code>, which is a kind
        of <code>Subdomain</code> that contains the core elements of
        your enterprise domain.
      </p>

      <p>
        As you can see in the code, we need to gather up all
        our <code>Persistents</code> and <code>Embeddables</code> into a
        <code>PTypePool</code> and <code>ETypePool</code>,
        respectively. These are simple collections
        of <code>PTypes</code> and <code>ETypes</code>; You can think
        of them as sets.
      </p>

    </div>

    <div>
      <h2>Building the Longevity Context</h2>

      <p>
        Once we have your subdomain in place, we are ready to build
        our <code>LongevityContext</code>, as we do on line 20 of 
        <a href="#code/src/main/scala/simbl/SimblContextImpl.scala"
        class="shortcut"><code>SimblContextImpl.scala</code></a>. The
        longevity context provides a variety of tools that are
        tailored to your subdomain. The most important of these is
        the <code>RepoPool</code>, which contains repositories for
        your persistent objects. You can use these repositories to do
        standard CRUD operations (create/retrieve/update/delete), as
        well as executing queries that return more than one result.
      </p>

      <p>
        Apart from the subdomain itself, we have to provide
        a <code>PersistenceStrategy</code> when building the longevity
        context. Your choices are
        currently <code>InMem</code>, <code>Mongo</code>,
        and <code>Cassandra</code>. We use <code>InMem</code> out of
        the box, so that this tutorial will work even if you don't
        have a MongoDB or Cassandra database set up for use.
      </p>

      <p>
        Longevity
        uses <a href="https://github.com/typesafehub/config">Typesafe
        Config</a> to configure the longevity context. Typically, the
        configuration is drawn from
        the <a href="#code/src/main/resources/application.conf"><code>application.conf</code></a>
        resource file. Here, you can find configurations for main and
        test databases for both Mongo and Cassandra. If you want to
        experiment with adjusting the persistence strategy to use a
        real database, you may need to tweak this configuration.
      </p>
      
    </div>

    
  </body>
</html>
